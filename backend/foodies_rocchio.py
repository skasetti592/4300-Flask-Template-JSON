# -*- coding: utf-8 -*-
"""FOODIE$_generatecossim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ECal3YrKCy240iBwKr4VvzFKCdHXQcyM
"""

import pandas as pd
import numpy as np
from numpy import linalg as LA
from sklearn.feature_extraction.text import TfidfVectorizer
import re


# loading dataset
#df = pd.read_csv("dataset.csv")

def rocchio_results(df, query, feedback):

  #Uses the Comments column and creates the TF-IDF matrix
  reviews = df['comments'].tolist()
  tfidf_vectorizer = TfidfVectorizer()
  tfidf_matrix = tfidf_vectorizer.fit_transform(reviews).toarray() # 3060 x 6506 matrix
  tfidf_matrix # currently very sparse - an option is to make it dense but more costly in memory

  """This is an example query which should be switched out to the user input"""

  query_tfidf = tfidf_vectorizer.transform([query]).toarray()

  types = set()

  for entry in df["type"]:
    temp = re.findall(r'[a-z]+', entry.lower())
    for val in temp:
      types.add(val)

  """Tokenizes the query and makes a set of the restaurant types in the query"""

  qtokens = re.findall(r'[a-z]+', query.lower())
  qtokens = set(qtokens)
  qtypes = set()
  for t in qtokens:
    if t in types:
      qtypes.add(t)

    relevant_docs = feedback # list of relevant document indices
    print(relevant_docs)
    print("This is relevant")
    print("Length of tfidf_matrix:", len(tfidf_matrix))
    print("Max index in relevant_docs:", max(relevant_docs))
    print("Min index in relevant_docs:", min(relevant_docs))

    non_relevant_docs = []  # list of non-relevant document indices

    # Extract relevant and non-relevant document indices from feedback
    #for entry in feedback:
     #   if entry['liked']:
      #      relevant_docs.append(entry['restaurant_id'])
       # else:
        #    non_relevant_docs.append(entry['restaurant_id'])

    # Rocchio algorithm parameters
    alpha = 1  # weight for the query vector
    beta = 0.75  # weight for the relevant documents vector
    gamma = 0.25  # weight for the non-relevant documents vector

    # Initialize query vector
    query_vector = alpha * query_tfidf  # initialize query vector with alpha * query_tfidf

    # Update query vector based on relevant documents
    if relevant_docs:
        relevant_vectors = tfidf_matrix[relevant_docs]
        relevant_vector = np.mean(relevant_vectors, axis=0)
        query_vector += beta * relevant_vector

    # Update query vector based on non-relevant documents
    if non_relevant_docs:
        non_relevant_vectors = tfidf_matrix[non_relevant_docs]
        non_relevant_vector = np.mean(non_relevant_vectors, axis=0)
        query_vector -= gamma * non_relevant_vector

    # Calculate cosine similarity between updated query vector and all documents
    rocchio_cossims = []
    for i in range(len(tfidf_matrix)):
        doc = tfidf_matrix[i]
        mov1norm = np.sqrt(np.sum(np.square(query_vector)))  # get the norm of the vector
        mov2norm = np.sqrt(np.sum(np.square(doc)))  # get the norm of the vector
        num = np.dot(query_vector, doc)  # dot product the vectors
        den = mov1norm * mov2norm  # dot product the norms
        if den == 0:
            rocchio_cossims.append((i, 0))
        else:
            temp = num / den
            rocchio_cossims.append((i, temp))

    rocchio_cossims_sorted = sorted(rocchio_cossims, key=lambda x: x[1], reverse=True)

    # Return the top restaurant names after applying Rocchio algorithm
    top_restaurants = []
    threshold = 5
    num = len(rocchio_cossims_sorted)
    if len(qtypes) == 0 or len(rocchio_cossims_sorted) < threshold:
        for i in range(5):
            top_restaurants.append(df.at[rocchio_cossims_sorted[i][0], 'name'])
    else:
        for i in range(5):
            top_restaurants.append(df.at[rocchio_cossims_sorted[i][0], 'name'])
    return top_restaurants
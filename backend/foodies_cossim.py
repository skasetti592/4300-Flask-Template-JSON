# -*- coding: utf-8 -*-
"""FOODIE$_generatecossim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ECal3YrKCy240iBwKr4VvzFKCdHXQcyM
"""

import pandas as pd
import numpy as np
from numpy import linalg as LA
from sklearn.feature_extraction.text import TfidfVectorizer
import math
import re

# loading dataset
#df = pd.read_csv("dataset.csv")

def cossim_full(df, query):
  """Creates a dictionary of the restaurant name and the value is the index"""

  restaurant_to_index = {}

  for idx, name in enumerate(df["name"]):
    restaurant_to_index[name] = idx

  """Uses the Comments column and creates the TF-IDF matrix"""

  reviews = df['comments'].tolist()
  tfidf_vectorizer = TfidfVectorizer()
  tfidf_matrix = tfidf_vectorizer.fit_transform(reviews).toarray() # 3060 x 6506 matrix
  tfidf_matrix # currently very sparse - an option is to make it dense but more costly in memory

  """This is an example query which should be switched out to the user input"""

  query_tfidf = tfidf_vectorizer.transform([query]).toarray()

  """Note: take the index on the csv file and subtract by 2 to get the index in the df

  This computes the cossim between each restaurant and the query and sorts it from most relavent to least relavant
  """

  cossims = []
  for i in range(len(tfidf_matrix)):
    doc = tfidf_matrix[i]

    mov1norm = LA.norm(query_tfidf) # get the norm of the vector
    mov2norm = LA.norm(doc) # get the norm of the vector

    num = np.dot(query_tfidf, doc) # dot product the vectors
    den = np.dot(mov1norm, mov2norm) # dot product the norms

    if den == 0:
      cossims.append((i, 0))
    else:
      temp = num / den
      cossims.append((i, temp))

  cossims_sorted = sorted(cossims, key=lambda x: x[1], reverse=True)

  """This creates a set of all of the restaurant type"""

  types = set()

  for entry in df["type"]:
    temp = re.findall(r'[a-z]+', entry.lower())
    for val in temp:
      types.add(val)

  """Tokenizes the query and makes a set of the restaurant types in the query"""

  qtokens = re.findall(r'[a-z]+', query.lower())
  qtokens = set(qtokens)
  qtypes = set()
  for t in qtokens:
    if t in types:
      qtypes.add(t)

  qtokens

  """Note: there is a potential bug - if they do not put in a word in the query that is not in the types dictionary"""

  results = []
  for i, cs in cossims_sorted:
    entry = df.at[i, "type"]
    temp = re.findall(r'[a-z]+', entry.lower())
    for t in temp:
      if t in qtypes:
        results.append((i, cs))

  len(results)

  """This prints the results! Prints from highest to lowest cossim scores and ONLY if it matches the restaurant type.
  Right now, I am just printing out the first 5 results but the website would just print all of them.
  ALSO POTENTIAL BUG IS FIXED HERE
  """

  threshold = 5 # this can be changed
  final = []
  if len(qtypes) == 0 or len(results) < threshold: # if there are no types in the query or if there are not at least 5 results
    for i in range(10):
      final.append(df.at[cossims_sorted[i][0], 'name'])
      #print(df.at[cossims_sorted[i][0], 'name'])
  else: # otherwise print out the filtered results
    for i in range(10):
      final.append(df.at[results[i][0], 'name'])
      #print(df.at[results[i][0], 'name'])
  return final